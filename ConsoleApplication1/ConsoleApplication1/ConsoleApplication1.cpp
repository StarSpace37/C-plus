// ConsoleApplication1.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

/*
#include <iostream> //<---------- подключение библиотеки для ввода и вывода

int mAin() //<---------- функция
{
    std::cout << "Hello World!\n"; //<---------- вывод в концоль
}
*/
// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.

/*
Это эскейп-последовательность
\b Удаление последнего выведенного символа
\n Перейти на начало новой строки (энтр)
\t Перейти к следующей позиции табуляции (пробел)
///////////////////////////////
\\ Вывести обратную черту \
\" Вывести двойную кавычку "
\' Вывести одинарную кавычку '
*/

/*
Типы данных (их 3 по сути) Числовие, Символьние, Логические. (переменные)
рассмотрим из так 1)Тип данных(значение) 2)Размер в байтах(сколько места займёт) 3)Пояснения(диапазон и тд)

1)Числа с плавающей точкой (Дробные числа)
float (4) описывает вещественные числа одинарной точности (одинарная точность)
double (8) описывает вещественные числа двойной точности (двойная дробь, гаразда больше диапозон значения)

Целые числа
int (4) описывает целые числа от-2147483648 до 2147483647
short (2) описывает короткие целые числа от-32768 до 32767
long (4) описывает длинные целые числа от-2147483648 до 2147483647 (почти никогда не пользуются но можно совмешаться и комбинироваться с ЗНАЧЕНИЕМ int)

2)Символьный тип
char (1) описывает символы (любые символы и буквы и даже больше того что мы можем найти на клавиатуре)

3)Логический тип
bool (1) описывает логические значения true, false (ДА или НЕТ, ПРАВДА или ЛОЖ, 1 или 0)
*/

#include <iostream>
#include <ctime> //<---------- подключил новую библиотеку когда дошел до масивоф 540 строчка (когда делал генератор случайных чисел)
using namespace std; //<---------- пространство имён, тоесть оно для того чтобы программа понимала что я хочу КАЖДОЙ функции ниже, чтобы не писать вот так (STD::cout << "Hello World!" << STD::endl;) для понимания кампилятора (с помошью пространства имён std)


// переменные это как бирочка или ярлычёк которая может менятся, имя для данных которые мы будем находить и работать (записывается она так ТИП_ДАННЫХ ИМЯ_ПЕРЕМЕННОЙ)
/*
void main() //<---------- пустая функция
{
    cout << "Hello World! Привет Мир!" << endl; // <---------- русское НЕ будет понятно (это функция в начале т в конце)
    setlocale(LC_ALL, "Rus"); // <---------- коректное отоброжение русских символов, работает только когда находится перед русским словом для ввода в концоль (это функция)
    cout << "Hello World! Привет Мир!\n"; // <---------- русское будет понятно ("привет мир"-это символьный МАСИВ)

    int age; // <---------- могу назвать абсолютно как угодно если не будет состоять не с 2 отдельных слов например вместо AGE будет qzrvump но тогда находить будет сложно по этому называем по сушеству!
    age = 18; // <---------- если я не назначу никакого значения то это ошибка!
    cout << age << endl;
    age = 27;
    cout << age << endl;

    int ageSpace = 43; // <----------(Только англ и 2 слова можно слитно где второе будет с большой буквы)
    cout << ageSpace << endl;

    int age1, a, b; // <---------- можно назначить сразу несколько переменных  (я воспользовался ещё раз "int age" это ошибка, я могу написать "int age1" и всё будет работать! одинаковые имена нельзя. Цифры можно)
    age1 = 38;
    a = 2;
    b = 5;
    cout << age1 << " " << a << " " << b << endl;  // <---------- ""-это пробелы, если их не поставить то цыфры будут слитно и мы подумаем что А и В это = 25 (cout << age << "" << a << b << endl;) иежду ними надо "кавычки"

    int age2=47.684, a1=142, b1=2896; // <---------- можно прям сразу ставить им цифры (age2 я записал как дробь, но не в double по этому дробь просто отбрасываеться)
    cout << age2 << " " << a1 << " " << b1 << endl;

    double age3 = 47.684; // <---------- всё правильно дробь видно (назвать "age2" я не мог это уже занятое имя)
    cout << age3 << endl;

    char c = 'f'; // <---------- только с 'такими' скобками '', НЕ с "такими"! ""
    cout << c << endl;

    bool e = true;
    bool f = false;
    cout << e << "\n" << f << endl;

    //константа это как переменная НО константа не меняется как переменная (напримет мы ж не можем изменить количество дней в неделю, их 7 и они не поменяются)
    const int COUNT_DAYS_IN_WEEK = 7; // <---------- количество дней в неделе (это мы уже не поменяем)
    cout << COUNT_DAYS_IN_WEEK << "\n";
    const char NEW_LINE = '\n'; // <---------- указал константу так что тепереь слова NEW_LINE будут выполнять действия \n и перекидовать меня на след строчку (пример нижу)
    cout << COUNT_DAYS_IN_WEEK << NEW_LINE;
    // Вод данных

    int Var, Var2;

    cout << "Введите 1 число: ";  // <---------- тоесть я сделал кон где уже могу вводить данные, в этом случае цифры
    cin >> Var;

    cout << "Введите 2 число: ";
    cin >> Var2;

    //cin >> Var>>Var2; <---------- в принцыпе тоже самое

    cout << "Вы ввели число 1 =" << Var << endl << "Вы ввели число 2 =" << Var2 << endl;

    a = -a; // <---------- если бы у меня тут а = -2 то в Ctrl+F5 получилось бы 2
    cout << a << endl;

    int v = a + b; // <---------- b = 5, а = 2, но я потом поменял а = -а и стало -2 и тут написал что V = a + b (-2+5=3)
    cout << v << endl; // <---------- тут можно было поступить просто (cout << a + b << endl;) получили бы это же
    cout << a * b << endl;
    v = 2 + 2 * 2; // <---------- помним со школы что приоритет у умножения и будет не 8 а 6
    cout << v << endl;
    v = (2 + 2) * 2; // <---------- у () больше приоритет
    cout << v << endl;
}
*/

/*
    //Операторы (они бывают 3 видов)
    1)Унарные (это которому для действия нужен только один ОПИРАНТ)
    2)Бинарные (само собой тут два операнта)
    3)Тернарные (тут три)

    Название оператора
        Сложение (+) 5 + 3 = 8
        Вычитание (-) 8 - 3 = 5
        Умножение (*) 2 * 3 = 6
        Деление (/) 5 / 2 = 2
        Деление по модулю (%) 5 % 2 = 1
    Также есть операции равенства
        =  присвоить (когда в переменных мы пишем а=3 мы "а" присваиваем 3-ку)
        ==  равен (важно знать что если мы ставим "=" то это означает "присвоить", а вот так это уже равно "==")
        !=  не равен
    И операции сравнения
        <  меньше
        >  больше
        <=  меньше или равно
        >=  больше или равно
    Логические операторы объединения и отрицательная инверсия
        && - логическая  И
        || - логическая  ИЛИ
        != - логическая  НЕ
*/

/*
void main()
{
    setlocale(LC_ALL, "Rus");
    /*
    int a, b, c;
    //int sum, mult;
    //double average;
    cout << "Введите 3 числa: " << endl;
    cin >> a >> b >> c;
    //sum = a + b + c;
    cout << "Сумма 3 чисел= "<< a + b + c << endl;
    //mult = a * b * c;
    cout << "Производное 3 чисел= " << a * b * c << endl;
    //average = (double) (a + b + c) / 3; среднее арефм. сложить их и поделить на их количество
    cout << "Среднее от 3 чисел= " << (double)(a + b + c) / 3 << endl;
    */

    /*
    int a = 1,b;
    cout << a << endl;
    a = a + 5;
    cout << a << endl;
    a++; // <---------- инкримент (больше на 1)
    cout << a << endl;
    a--; // <---------- дикримент (меньше на 1) когда ++ или -- идут после "а" то это посфексный способ
    cout << a << endl;

    //cout << a++ << endl; // <---------- если я напишу вот так то цыфра не изменится
    cout << --a << endl;// <---------- но можно изминить приоритет постфиксный инкремент вот так (с этого а++ на этот ++а)! и тогда цыфра изменится так как нам надо
    b = ++a * a++; // <---------- постфиксный инкремент (а++) не влеяет не как на уровнение т.к. увиличение на +1 выполняется после выводя...
    cout << b << endl;
    */

    /*
    int a = 0;
    cout << a << endl;
    a = a + 20; // <---------- если нам понадобится не +1 (a++) а +20 например, то можно написать проще
    cout << a << endl;
    a += 20;
    cout << a << endl;
    a -= 10;
    cout << a << endl;
    a *= 4;
    cout << a << endl;
    a /= 2;
    cout << a << endl;
    */

    /*
    int a = 3;
    int b = 3;

    cout << !(a==b) << endl;  // <---------- перед дужками я проставил знак восклицания, это отрицает и инвентирует все решение в дужках тоесть ответ должен быть ТРУ 3==3 (1) но мне выдаст ФОЛЗ (0)
    cout << ((a == b)&&(5>4)&&(0!=1)) << endl;  // <---------- здесь истина (1)
    cout << ((a == b) || (5 > 6)) << endl; // <---------- тут первое верно другое не верно, но если хоть одно верное я уже получу тру (1)
     */

     //конструкция логического выбора if (лесенка if - else if)
    /*
    bool isRain = true; // <---------- bool это мы выбрали логические значения ТРУ и ФОЛЗ, isRain это я дал имя переменной и назначил ей значение ТРУ

    if (isRain) // <---------- if тоесть логичиская ЕСЛИ (если "идёт дождь") если действие подтвердилось, то что находится в дужках (например как я тут написал ИДЁТ ДОЖДЬ) то это будет ТРУ (правда) значит будет эта натпись {Идёт дождь, нам нужен зонт!}
    {
        cout << "Идёт дождь, нам нужен зонт!" << endl; // <---------- НО если дождь не идёт то это ФОЛЗ (не правда) значит решение будет другим (тем что ниже)
    }
    else // <---------- else логическая ИЛИ (или "дождь не идёт") значение ФОЛЗ, ...
    {
        cout << "дождя нет, зонт не нужен!" << endl; // <---------- ...значит будет эта натпись
    }

    int a; // <---------- у нас есть А и она должна быть цифрой ибо int
    cout << "Введите число от 1 до 10" << endl; // <---------- просто заголовок
    cin >> a; // <---------- место для ввода цифры

    if (a > 5) // <---------- пишу логику ТРУ будет если та цыфра что мы вписали будет больше 5...
    {
        cout << "ваше число больше 5-ти" << endl; // <---------- ...тогда мы и увидем
    }
    else if (a == 5) // <---------- но если число и будет 5 то она не может быть не больше не меньше она равна 5
    {
        cout << "ваше число равно 5-ти" << endl;
    }
    else // <---------- или цыфра что мы нажали не больше не равно пить, значит ФОЛЗ а если фолз то...
    {
        cout << "ваше число меньше 5-ти" << endl; // <---------- ...мы увидем это
    }

    int var; // <---------- c этим кампилятором дробные числа не подходят
    cout << "чётное или не чётное" << endl;
    cin >> var;
    if (var%2==0) // <---------- символ % означает поделить с остатком (1) или без остатка (0) тоесть чётное или не чётное (в этом случае я делю на 2)
    {
        cout << "Число " << var << " чётное" << endl;
    }
    else
    {
        cout << "Число " << var << " не чётное" << endl;
    }
    */

    /*
    switch (выражение)
case значение1: break; действие1;
case значение2: break; действие2;
case значение3: break; действие3;
default: действие_по_умолчанию; break;
    */

    /*
    int a;
    cout << "введите 1, 2 или 3" << endl;
    cin >> a;
    switch (a) // <---------- Свичь по сути как ИФ и ЕЛС но работает чёткими скриптами и по сути когда надо написать большой код
    {
    case 1: // <---------- то что я введу там (тоесть если я введу 1 то...)
        cout << "вы ввели 1" << endl;// <----------(...то увижу это)
        break; // <---------- и тогда действие кончится
    case 2:
        cout << "вы ввели 2" << endl;
                // <---------- тут нет break по этому действие продолжится, тоесть если впишу 2 то я увижу и 3 (иногда это полезно)
    case 3:
        cout << "вы ввели 3" << endl;
        break;
    default:  // <---------- дэфолтное значение (ну например я напишу чтото кроме 1, 2 или 3)
        cout << "я же попросил нормально" << endl;
        break;
    }
    */

    /*
    int a, b, selection;  // <---------- калькулятор
    cout << "Введите 2 числа" << endl;
    cin >> a >> b;
    cout << "Выберите математическую операцию" << endl <<
        "1. Сложение" << endl <<
        "2. Вычитание" << endl <<
        "3. Умножение" << endl <<
        "4. Деление" << endl;
    cin >> selection;
    switch (selection)
    {
    case 1:
        cout << "Результат сложения " << a + b << endl;
        break;
    case 2:
        cout << "Результат вычитания " << a - b << endl;
        break;
    case 3:
        cout << "Результат умножения " << a * b << endl;
            break;
    case 4:
        cout << "Результат деления " << (float) a / b << endl;   // <---------- тут я утачнил (float) что-бы считать в дробных числах например захочу 5/4
            break;


    default:
        cout << "Ошибка" << endl;
        break;
    }

    int a = 8; // <---------- с этой цифры начнётся отщёт (если тут поставить 20 то в F5 ничего не выполенится, но...)

    do // <---------- ...если дописать DO перед WHILe то хотяб 1 он выполнится по любому
    {
        cout << "Ошибка! а = " << a << endl;
        a++;
    }
    while (a < 20);  // <---------- если утверждение в скобках будет ТРУ то выполнится действие в фигурных скобках
    {
        cout << "Ошибка! а = "<< a << endl; // <---------- интеракция цикла будет с 9 до 19 ибо 20 будет по условию не меньше 20 а равно, по этому остановится в 19
        a++; // <---------- инкримент
    }
    */

    /*
    int symbolCount;
    char sybol;
    int lineType;
    int index = 0;
    cout << "Введите количество символов в линии" << endl;
    cin >> symbolCount;
    cout << "Ведите символ" << endl;
    cin >> sybol;
    cout << "Выберите тип линии: " << endl
        << "1- вертикальная линия" << endl
        << "2- горизонтальная линия" << endl;
    cin >> lineType;

    if (lineType != 1 && lineType != 2)
    {
        cout << "Ошибка! вы ввели чтото кроме 1 или 2" << endl;
        return;
    }
    while (index<symbolCount) // <---------- цыкл
    {
        if (lineType == 1)
        {
            cout << sybol << endl;
        }
        if (lineType == 2)
        {
            cout << sybol;
        }
        index++;
    }
    cout << endl << endl;
    */

    /*
    int sum = 0;
    int rangeBegin, rangeEnd;
    cout << "Введите начало диапазона" << endl;
        cin >> rangeBegin;
    cout << "Введите конец диапазона. " << endl;
    cin >> rangeEnd;
    do
    {
        if (rangeBegin % 2 != 0)
        {
            sum += rangeBegin;
        }
        rangeBegin++;
    } while (rangeBegin < rangeEnd);
    cout << "сумма всех нечётных чисел " << sum << endl;
    */

    /*
    int i = 0;
    cout << "1 цикл" << endl;
    for (; i < 10; i++) // <---------- for это тоже цыкл но им удобнее работать с масивами (это забегая вперёд) можно писать вот так  (int i = 2; i < 13; i++) если бы я не прописал выше это int i = 2; (главное не убераем ;)
    {
    cout << "переменная i = " << i << endl;
    }
    cout << "2 цикл" << endl;
    for (; i < 20;) // <---------- для этого мы и иницыалезировали i=2 не в скобкох а сверху, изза ОБЛАСТИ ВИДИМОСТИ (что в скобках видно только этим скобкам и этой функции или переменной)
    {
        cout << "переменная i = " << i << endl;
        i++; // <----------  i++ была в дужках ну мы легко можем переложить ее в фигурные и всё равно результат будет темм же (но важно  где i++ стоит, до cout или после)
    }

    for (int i = 0, j = 10; i < 10 && j!=5; i++, j--)
    {
        cout << "переменная i= " << i << endl;
        cout << "переменная j= " << j << endl;
    }
    */

    /*
    cout << "начало цикла" << endl;
    for (int i = 0; i < 10; i++)
    {
        cout << "переменная і = " << i << endl;
        if (i == 5)
        {
            break;
        }
    }
    cout << "конец цикла" << endl;
    */

    /*
    cout << "начало цикла" << endl;
    int i = 0;
    while (true)
    {
        cout << "переменная і = " << i << endl;
        i++;
        if (i == 6)
        {
            break; // <---------- тормозит весь процес (применяется много где например в твич...)
        }
    cout << "конец цикла" << endl;
    }
    */

    /*
    for (int i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            continue;
        }
        cout << "переменная і = " << i << endl;
    }
    */

    /*
    cout << "1" << endl; // <---------- если мы хотим после 1 перепрыгнуть сразу на 4 и 5 делаем так... (лучше вообще её и не трогать)

    goto link; // <---------- перейти на ссылку

    cout << "2" << endl;
    cout << "3" << endl;

    link: // <---------- сама ссылка

    cout << "4" << endl;
    cout << "5" << endl;
    */

    /*
    // <---------- Отладка (нажимаем F10 этим мы проверяем код по очереде, а если надо проверить 1 строчку нажимаем F9 на строчке там появится красная точка, а потом F5 для начала проверки, можем нажать теперь F10 и мы перескочим дальше)
    int a = 5;
    int b = 7;
    int c;
    c = a + b;
    cout << c << endl;
    // <---------- Остановить отладку (шифт F5)
    */

    /*
    for (int i = 1; i < 5; i++)
    {
        cout << "цикл №1 = " << i << endl;
        for (int j = 1; j < 5; j++)
        {
            cout << "\t цикл №2 = " << j << endl;
        }

    }
    */

    /*
    int heigth, width;
    cout << "Введите высоту прямоугольника" << endl;
    cin >> heigth;
    cout << "Введите ширину прямоугольника" << endl;
    cin >> width;
    for (int j = 0; j < heigth; j++)
    {
        for (int i = 0; i < width; i++)
        {
            cout << "*";
        }
        cout << endl;
    }
    cout << endl;

}
*/

void foo() // <---------- для функции 
{
    cout << "Я функция, меня вызвали!" << endl;
}

int Sum(int a, int b)// <---------- для функции 
{
    int result; // <---------- не обязательно 
    result = a + b;
    return result; // <---------- не обязательно
}

void main()
{
    std::cout << "Hello World!\n";
    setlocale(LC_ALL, "ru");
    // <---------- МАСИВЫ! (переменные одного типа, масив не может хронить переменные разных типов такие как с++ с# java (например php пофигу что и где будет)) масивы бывают статические и динамические 

    /*
    int arr[4]; // <---------- int-цифры, arr-сам назвал масив, []-назначаю количество масива

    arr[0] = 5;
    arr[1] = 17;
    arr[2] = 201;
    arr[3] = 4231;

    cout << arr[0] << endl;
    */

    /*
    int arr[] = {5, 4231, 17, 201}; // <---------- []- нет цифр это нормально мы назначили цифры тут {} а кампилятар за нас сам пощетает сколько их (можно писать без ="")

    cout << arr[3] << endl;
    */
    // <---------- циклы для МАСИВОВ! 
    /*
    const int size = 5;

    int arr[size]{ 5, 4231, 17, 201 }; // <---------- в масиве 5 элиментов, цифры я дал для 4, (0,1,2,3,4) 5-му элементу будет назначено н0оль (size надо было написать большими конечнои)

    int a = sizeof(arr); // <---------- тип масива
    int b = sizeof(int); // <---------- тип вида данных

    cout << sizeof(arr)/sizeof(int) << endl;

    for (int i = 0; i < size; i++) // <---------- for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++) такая запись тоже возможна
    {
        cout << arr[i] << endl;
    }
    */

    /*
    int arr[]{ 5, 4231, 17, 201 };  // <---------- сколько хочешь цифр столько и будет

    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        cout << arr[i] << endl;
    }
    */

    // <---------- ГЕНЕРАТОР СЛУЧАЙНЫХ ЧИСЕЛ 
    /*
    srand(time(NULL));
    int a = rand(); // <---------- если тут написать вот так int a = rand()%10; то будет с 0 до 10
    cout << a << endl;
    a = rand(); // <---------- если тут написать вот так a = rand()%10 + 5; то от 5 до 15 (потому что рандом цифра всегда будет с +5)
    cout << a << endl;
    */

    // <---------- ГЕНЕРАТОР СЛУЧАЙНЫХ ЧИСЕЛ (без повторений)
    /*
    int const SIZE = 10;

    int arr[SIZE];

    bool alreadyThere;

    for (int i = 0; i < SIZE; )
    {
        alreadyThere = false;
        int newRandomValue = rand() % 20;
       // arr[i] = rand()%20;
        for (int j = 0; j < i; j++)
        {
            if (arr[j] == newRandomValue)
            {
                alreadyThere = true;
                break;
            }
        }
        if (!alreadyThere)
        {
            arr[i] = newRandomValue;
            i++;
        }
    }


    for (int i = 0; i < SIZE; i++)
    {
        cout << arr[i] << endl;
    }
    */

    // <---------- ГЕНЕРАТОР СЛУЧАЙНЫХ ЧИСЕЛ 
    /*
    int const SIZE = 10;

    int arr[SIZE];

    bool alreadyThere;

    for (int i = 0; i < SIZE; )
    {
        alreadyThere = false;
        int newRandomValue = rand() % 20;

        for (int j = 0; j < i; j++)
        {
            if (arr[j] == newRandomValue)
            {
                alreadyThere = true;
                break;
            }
        }
        if (!alreadyThere)
        {
            arr[i] = newRandomValue;
            i++;
        }
    }

    int minValue = arr[0];
    for (int i = 1; i < SIZE; i++)
    {
        if (arr[i] < minValue)
        {
            minValue = arr[i];
        }
    }
    cout << "минимальное число из рандома " << minValue << endl;
    */
    // <---------- двумерный масив (вспомни сетку а [2] [1])
    /*
    const int ROW = 3;
    const int COL = 4;

    int arr[ROW][COL]; // <---------- если написать int arr[ROW][COL]{}; то в масивах будут нули, можно написать цифры {5, 3, 2, 9} и фигурные в фигурных {{2,4,6,8},{1,3,5,6}};

    cout << arr[1][1] << endl;

    arr[1][1] = 53;
    arr[2][0] = 19;

    cout << arr[1][1] << endl;

    int a;
    a = 0; // <-- это нам для атлатчика
    */

    /*
    const int ROWS = 5;
    const int COLS = 8;

    int arr[ROWS][COLS];

    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            arr[i][j] = rand()%10;
        }
    }
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            cout << arr[i][j] << "\t";
        }
        cout << endl;
    }
    */

    // <---------- ФУНКЦИИ (урок 34) возвращаемое значение имя функции (параметры) блок_повторяющегося_кода (тело); (void foo() cout << "Я функция, меня вызвали!" << endl) єто я зарание назначил функцию...
    foo(); // <---------- ctrl f5
    int c;
    int q = 11;
    int w = 12;
    c = Sum(2, w);
    cout << c << endl; // cout << Sum(q, w) << endl; <---------- так тоже можно это будет даже быстрее...
}
